import { Range, Editor, Extension } from '@tiptap/react';
import { SuggestionOptions } from '@tiptap/suggestion';
import * as react from 'react';
import react__default from 'react';
import * as _tiptap_core from '@tiptap/core';

type TipTapRange = Range;
type SlashSuggestionBase = {
    title: string;
    command: (props: {
        editor: Editor;
        range: TipTapRange;
    }) => void;
    searchTerms?: string[];
};
type SlashSuggestion<T extends Record<string, unknown> = Record<string, unknown>> = SlashSuggestionBase & T;
type SlashOptions<TSuggestion extends Record<string, unknown> = Record<string, unknown>> = {
    suggestion: Omit<SuggestionOptions<SlashSuggestion<TSuggestion>>, "editor">;
};

interface SlashItemProps {
    readonly onCommand: ({ editor, range, }: {
        editor: Editor;
        range: TipTapRange;
    }) => void;
}

declare const SlashCommand: {
    Root: (props: {
        children: React.ReactNode;
        editor?: _tiptap_core.Editor | null;
    }) => react.JSX.Element;
    Cmd: react.ForwardRefExoticComponent<Omit<Omit<Omit<{
        children?: React.ReactNode;
    } & Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild"> & {
        label?: string;
        shouldFilter?: boolean;
        filter?: (value: string, search: string, keywords?: string[]) => number;
        defaultValue?: string;
        value?: string;
        onValueChange?: (value: string) => void;
        loop?: boolean;
        disablePointerSelection?: boolean;
        vimBindings?: boolean;
    } & react.RefAttributes<HTMLDivElement>, "ref"> & {
        ref?: ((instance: HTMLDivElement | null) => void | react.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[keyof react.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES]) | react.RefObject<HTMLDivElement> | null | undefined;
    }, "id" | "onKeyDown">, "ref"> & react.RefAttributes<HTMLDivElement>>;
    List: react.ForwardRefExoticComponent<{
        children?: React.ReactNode;
    } & Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild"> & {
        label?: string;
    } & react.RefAttributes<HTMLDivElement>>;
    Item: react.ForwardRefExoticComponent<Omit<Omit<{
        children?: React.ReactNode;
    } & Omit<Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild">, "onSelect" | "disabled" | "value"> & {
        disabled?: boolean;
        onSelect?: (value: string) => void;
        value?: string;
        keywords?: string[];
        forceMount?: boolean;
    } & react.RefAttributes<HTMLDivElement>, "ref">, "onSelect"> & SlashItemProps & react.RefAttributes<HTMLDivElement>>;
    Empty: react.ForwardRefExoticComponent<{
        children?: React.ReactNode;
    } & Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild"> & react.RefAttributes<HTMLDivElement>>;
    Loading: react.ForwardRefExoticComponent<{
        children?: React.ReactNode;
    } & Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild"> & {
        progress?: number;
        label?: string;
    } & react.RefAttributes<HTMLDivElement>>;
    Separator: react.ForwardRefExoticComponent<Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild"> & {
        alwaysRender?: boolean;
    } & react.RefAttributes<HTMLDivElement>>;
    Group: react.ForwardRefExoticComponent<{
        children?: React.ReactNode;
    } & Omit<Pick<Pick<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof react.HTMLAttributes<HTMLDivElement>> & {
        ref?: React.Ref<HTMLDivElement>;
    } & {
        asChild?: boolean;
    }, "key" | keyof react.HTMLAttributes<HTMLDivElement> | "asChild">, "value" | "heading"> & {
        heading?: React.ReactNode;
        value?: string;
        forceMount?: boolean;
    } & react.RefAttributes<HTMLDivElement>>;
};

type SlashCmdProviderProps = {
    children: react__default.ReactNode;
};
/**
 * We need to wrap our entire editor in this provider, so that tippy can use our tunneled instance to communicate with the editor.
 */
declare const SlashCmdProvider: (props: SlashCmdProviderProps) => react__default.JSX.Element;

declare const createSuggestionsItems: <T extends Record<string, unknown> = Record<string, unknown>>(items: SlashSuggestion<T>[]) => SlashSuggestion<T>[];

declare const slashExtenstionSuggestion: Extension<SlashOptions, any>;

declare const renderItems: SuggestionOptions["render"];

declare const enableKeyboardNavigation: (event: KeyboardEvent) => true | undefined;

export { slashExtenstionSuggestion as Slash, SlashCommand as SlashCmd, SlashCmdProvider, createSuggestionsItems, enableKeyboardNavigation, renderItems };
